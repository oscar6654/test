## Learning Objectives

* Learn about React controlled components
* Understand the one-way flow of data between parent and child controlled components
* Use React controlled components to create forms on our page

## Following Along - Code Example

To get quick set up, run the following:

```sh
$ et get react-forms
$ cd react-forms
$ npm install
$ npm start
```

## Introduction

Traditional HTTP forms are static. The server renders a number of inputs on the page, and once the user fills out the form, they can choose to submit it (usually by clicking a "Submit" button.) At that point, a sort of snapshot is taken, capturing the current state of all of the inputs, and sending that data in an HTTP request back to the server. This behavior is a result of how HTTP works: once the server has sent the blank form, it forgets about it, and receives no further communication until the user makes their submission.

As you have probably come to expect, form components in React are much more dynamic. They make use of a parent component (often called a "container") to maintain information about not only the default, blank form, but also what changes as the user interacts with it and fills it out, in real-time. Each of the inputs of the form is rendered as a child component of that parent, which we called a *controlled component*.

## Containers

Here we have a simple food-tracking app, for documenting daily consumption. Take a look at this file:

```javascript
// src/containers/App.js
import React, { Component } from 'react';
import FormContainer from './FormContainer';
import MealsList from '../components/MealsList';

class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      meals: []
    }
    this.trackConsumption = this.trackConsumption.bind(this);
  }

  trackConsumption(submission) {
    this.setState({ meals: this.state.meals.concat(submission) })
  }

  render() {
    return (
      <div className="row">
        <div className="small-9 small-centered columns">
          <h1 className="text-center">Food Tracker</h1>
          <FormContainer trackConsumption={this.trackConsumption} />
          <MealsList meals={this.state.meals} />
        </div>
      </div>
    );
  }
}

export default App;

```

This is the highest-level component in our application. It creates two child components: `FormContainer` and `MealList`, and passes `props` down to both of them. Pay particular attention to this line:

```javascript
this.trackConsumption = this.trackConsumption.bind(this);
```

This binding ensures that, when the `trackConsumption` function is called, a new meal can be added to the array of existing meals in the `state` variable that exists on our `App` component. This change will propagate down to our `MealList` component, which displays a simple list of meals consumed. The `trackConsumption` function isn't called in this `App` container, however: it's passed down as a prop to the `FormContainer`, so that it can be called from there.

```javascript
// src/containers/FormContainer.js
// ...

  handleFormSubmit(event) {
    event.preventDefault();
    if (
      this.validateConsumedChange(this.state.foodItemConsumed) &&
      this.validateMealSelection(this.state.mealSelected)
    ) {
      let formPayload = {
        food: this.state.foodItemConsumed,
        meal: this.state.mealSelected
      };
      this.props.trackConsumption(formPayload);
      this.handleClearForm(event);
    }
  }
```

We make use of a similar pattern in the `FormContainer` itself to create our controlled components.

## Controlled Components

There are two important characteristics of a controlled component, both having to do with the props which are passed down to it from its parent container. A controlled component receives:

1. A function that is called for every `onChange` event, which passes its input data up to the parent.
2. That same data, which is then displayed inside the input.

If that seems a little circular to you, that's because it is. It's an example of *unidirectional flow*: a simple cycle that ensures that both parent and child have access to the same data, generated by interaction with the user. Let's look at an example:

```javascript
// src/containers/FormContainer.js
// ...

  render() {
    return (
      <form className="callout" onSubmit={this.handleFormSubmit}>
        ...
        <TextField
          content={this.state.foodItemConsumed}
          label='Food Item Consumed'
          name='consumed'
          handlerFunction={this.handleConsumedChange}
        />
        ...
      </form>
    );
  }
  ...
```

```javascript
// src/components/TextField.js
import React from 'react';

const TextField = props => {
  return (
    <label>{props.label}
      <input
        name={props.name}
        onChange={props.handlerFunction}
        type='text'
        value={props.content}
      />
    </label>
  );
}

export default TextField;
```

Notice that our `TextField` receives both of the props described above. It has a function, passed down as `handlerFunction`, which it calls `onChange`. And its input's `value` attribute is passed down to it as `content`. If this is truly a controlled component, that `handlerFunction` (which comes from the parent component, where it's called `handleConsumedChange`) must be setting the value of content. And it is:

```javascript
// src/containers/FormContainer.js
// ...

  handleConsumedChange(event) {
    ...
    this.setState({ foodItemConsumed: event.target.value })
  }
```

The `handleConsumedChange` function sets the value of the target (the input) into state as `foodItemConsumed`. This in turn is how it is passed down to the `TextField` component as props, as `this.state.foodItemConsumed`. And the same thing is being done with the props and value of the `Select` component. Examine it for yourself, and see if you can follow the flow of data.

![Unidirectional data flow diagram](https://s3.amazonaws.com/horizon-production/images/react-unidirectional-flow.png)

This powerful pattern is frequently leveraged when making forms in the React.js framework. Among other uses, it is considered a best practice way to pass your user-inputted data from container to presentational components, so that they may be displayed on the page.

## Validation

Another benefit to this architecture is that it enables us to validate user input not only when a form is submitted, but with each interaction our users make with the form &ndash; every click and keystroke that triggers our `onChange` functions. Consider, for instance, the Meal dropdown created by our `Select` component.

```javascript
// src/components/Select.js
// ...

const Select = props => {
  let optionElements = props.options.map(option =>{
    return (
      <option key={option} value={option}>{option}</option>
    );
  })

  return (
    <label>{props.label}
      <select name={props.name} value={props.selectedOption} onChange={props.handlerFunction}>
        <option value=""></option>
        {optionElements}
      </select>
    </label>
  );
}

export default Select;

```

When the page loads, the value of the `select` element (received from `props.selectedOption`) will be an empty string, corresponding to the blank option. This is obviously not acceptable input, so in our `handleFormSubmit` function, we call `validateMealSelection`, a validation function we have defined thusly:

```
// src/containers/FormContainer.js
// ...

  validateMealSelection(selection) {
    if (selection === '') {
      let newError = { mealSelected: 'You must select a meal.' }
    ...
  }
```

However, because the `Select` is a controlled component, we can *also* call it in our `onChange` function, `handleMealSelection`, like so:

```
// src/containers/FormContainer.js
// ...

  handleMealSelection(event) {
    this.validateMealSelection(event.target.value)
    ...
  }

```

The upshot is that if the user selects a meal, and then changes their mind and re-selects the blank option from the dropdown, this error will appear on the page &ndash; even *before* they submit the form. And, in fact, because the form submission is being handled by our `handleFormSubmit` function (and not the default HTTP behavior), we can prevent the form from being submitted at all (whether that means making a POST request to our server, or simply displaying the submitted data on our page) until all the validation errors have been resolved.

## Summary

This article has defined controlled components, and explained their use to move data in a one-way loop, from child to parent and back again, which we call *unidrectional data flow*. This data flow is particularly useful when creating forms in our React apps, as it provides easy handles to respond to (and validate) user input, without requiring a page load as would be needed in a traditional HTTP request/response cycle. Understanding this structure, and the way functions may be passed down to child components (and then invoked by them, to pass data up to their parents) is an important part of making fully-featured React front-end applications.

## Additional Resources

- [React Forms Official Documentation](https://facebook.github.io/react/docs/forms.html)
